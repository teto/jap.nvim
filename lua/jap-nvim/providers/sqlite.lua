--[[
Returns values based on an sqlite db generated by https://github.com/odrevet/edict_database
The db itself is generated via edict
--]]

-- (or sqlite3 = require('lsqlite3complete')) 
local sqlite3 = require('lsqlite3')
local config = require('jap-nvim.config')

local M = {}

function M.kanji_sql(kanji)
    return [[
SELECT character.*, 
GROUP_CONCAT(DISTINCT character_radical.id_radical) as radicals, 
GROUP_CONCAT(DISTINCT on_yomi.reading) AS on_reading, 
GROUP_CONCAT(DISTINCT kun_yomi.reading) AS kun_reading, 
GROUP_CONCAT(DISTINCT meaning.content) AS meanings 
FROM character 
LEFT JOIN character_radical ON character.id = character_radical.id_character
LEFT JOIN on_yomi ON character.id = on_yomi.id_character
LEFT JOIN kun_yomi ON kun_yomi.id_character = character.id 
LEFT JOIN meaning ON meaning.id_character = character.id 
WHERE character.id="]]..kanji..[[";
]]
end

--- how to j
---@return table
function M.lookup_kanji(kanji)

    print("Opening " .. config.kanjidb)
    local con, errmsg, _errcode = sqlite3.open(config.kanjidb, sqlite3.OPEN_READWRITE)
    local res = {}

    local req = M.kanji_sql(kanji)

    if not con then
        vim.notify(string.format("rikai: could not open %s:\n%s", config.kanjidb, errmsg))
    else
        print("Looking up kanji ".. tostring(kanji))
        for a in con:nrows(req) do
            -- vim.print(a)
            res [#res + 1] = a
        end
    end

    con:close()
    return res
end

-- lookup several kanjis
-- 押す works for the "simple" db if you need to test
function M.lookup_expression(word)
    print("Opening " .. config.jmdictdb)
    local con = sqlite3.open(config.jmdictdb)
    local res = {}
    -- TODO look wiki for expression

end

return M

